package loader

import "core:fmt"
import "core:time"
import "core:strings"
import "core:path/filepath"
import "../manifest"

// emit generates shell code for sourcing modules in dependency order
emit :: proc(modules: [dynamic]manifest.Module) {
    emit_header(len(modules))
    
    for module in modules {
        emit_module(module)
    }
}

// emit_header generates header comments with metadata
emit_header :: proc(module_count: int) {
    fmt.println("# Generated by Zephyr Shell Loader")
    fmt.println("# https://github.com/xDarkicex/zephyr")
    
    // Get current timestamp
    now := time.now()
    // Format timestamp manually since to_string might not be available
    fmt.printf("# Generated: %v\n", now)
    
    fmt.printf("# Total modules: %d\n", module_count)
    fmt.println("#")
    fmt.println("# This file is auto-generated. Do not edit manually.")
    fmt.println("# To regenerate, run: zephyr load")
    fmt.println()
}

// emit_module generates shell code for a single module
emit_module :: proc(module: manifest.Module) {
    emit_module_header(module)
    emit_module_settings(module)
    emit_pre_load_hook(module)
    emit_module_files(module)
    emit_post_load_hook(module)
    emit_module_separator()
}

// emit_module_header generates module separation comments
emit_module_header :: proc(module: manifest.Module) {
    fmt.printf("# === Module: %s v%s ===\n", module.name, module.version)
    if len(module.description) > 0 {
        fmt.printf("# %s\n", module.description)
    }
    if len(module.author) > 0 {
        fmt.printf("# Author: %s\n", module.author)
    }
    fmt.println()
}

// emit_module_settings exports module settings as ZSH_MODULE_* environment variables
emit_module_settings :: proc(module: manifest.Module) {
    if len(module.settings) == 0 {
        return
    }
    
    fmt.printf("# Settings for %s\n", module.name)
    
    for key, value in module.settings {
        // Convert module name and setting key to uppercase for environment variable
        module_name_upper := strings.to_upper(module.name, context.temp_allocator)
        key_upper := strings.to_upper(key, context.temp_allocator)
        
        // Replace any non-alphanumeric characters with underscores in module name
        clean_module_name := make([]u8, len(module_name_upper), context.temp_allocator)
        copy(clean_module_name, module_name_upper)
        for i in 0..<len(clean_module_name) {
            if clean_module_name[i] < 'A' || clean_module_name[i] > 'Z' {
                if clean_module_name[i] < '0' || clean_module_name[i] > '9' {
                    clean_module_name[i] = '_'
                }
            }
        }
        
        // Replace any non-alphanumeric characters with underscores in key
        clean_key := make([]u8, len(key_upper), context.temp_allocator)
        copy(clean_key, key_upper)
        for i in 0..<len(clean_key) {
            if clean_key[i] < 'A' || clean_key[i] > 'Z' {
                if clean_key[i] < '0' || clean_key[i] > '9' {
                    clean_key[i] = '_'
                }
            }
        }
        
        env_var := fmt.tprintf("ZSH_MODULE_%s_%s", string(clean_module_name), string(clean_key))
        
        // Properly escape the value for shell
        escaped_value := escape_shell_value(value)
        fmt.printf("export %s=%s\n", env_var, escaped_value)
    }
    
    fmt.println()
}

// escape_shell_value properly escapes a value for safe use in shell export
escape_shell_value :: proc(value: string) -> string {
    // For safety, always quote values and escape any quotes within
    escaped, _ := strings.replace_all(value, "\"", "\\\"", context.temp_allocator)
    return fmt.tprintf("\"%s\"", escaped)
}

// emit_pre_load_hook executes pre-load hooks with safety checks
emit_pre_load_hook :: proc(module: manifest.Module) {
    if len(module.hooks.pre_load) == 0 {
        return
    }
    
    fmt.printf("# Pre-load hook for %s\n", module.name)
    
    // Safety check: verify the function exists before calling it
    // This prevents errors if the hook function is not defined
    hook_name := strings.trim_space(module.hooks.pre_load)
    
    // Validate hook name contains only safe characters (alphanumeric, underscore, dash)
    if !is_safe_hook_name(hook_name) {
        fmt.printf("# WARNING: Skipping unsafe pre-load hook name: %s\n", hook_name)
        fmt.println()
        return
    }
    
    fmt.printf("if typeset -f %s >/dev/null 2>&1; then\n", hook_name)
    fmt.printf("    %s\n", hook_name)
    fmt.printf("else\n")
    fmt.printf("    echo \"Warning: Pre-load hook '%s' not found for module %s\" >&2\n", hook_name, module.name)
    fmt.printf("fi\n")
    fmt.println()
}

// is_safe_hook_name validates that a hook name contains only safe characters
is_safe_hook_name :: proc(name: string) -> bool {
    if len(name) == 0 {
        return false
    }
    
    // Hook names should only contain alphanumeric characters, underscores, and dashes
    // and should not start with a dash
    if name[0] == '-' {
        return false
    }
    
    for char in name {
        if !((char >= 'a' && char <= 'z') || 
             (char >= 'A' && char <= 'Z') || 
             (char >= '0' && char <= '9') || 
             char == '_' || char == '-') {
            return false
        }
    }
    
    return true
}

// emit_module_files sources all specified module files with proper path quoting
emit_module_files :: proc(module: manifest.Module) {
    if len(module.files) == 0 {
        return
    }
    
    fmt.printf("# Source files for %s\n", module.name)
    
    for file in module.files {
        // Construct full path to the file
        full_path := filepath.join({module.path, file})
        
        // Properly quote the path to handle spaces and special characters
        quoted_path := quote_shell_path(full_path)
        
        // Add existence check before sourcing
        fmt.printf("if [[ -f %s ]]; then\n", quoted_path)
        fmt.printf("    source %s\n", quoted_path)
        fmt.printf("else\n")
        fmt.printf("    echo \"Warning: Module file not found: %s\" >&2\n", quoted_path)
        fmt.printf("fi\n")
    }
    
    fmt.println()
}

// quote_shell_path properly quotes a file path for safe use in shell commands
quote_shell_path :: proc(path: string) -> string {
    // Use double quotes and escape any double quotes, backslashes, and dollar signs in the path
    escaped := path
    escaped, _ = strings.replace_all(escaped, "\\", "\\\\", context.temp_allocator)
    escaped, _ = strings.replace_all(escaped, "\"", "\\\"", context.temp_allocator)
    escaped, _ = strings.replace_all(escaped, "$", "\\$", context.temp_allocator)
    escaped, _ = strings.replace_all(escaped, "`", "\\`", context.temp_allocator)
    
    return fmt.tprintf("\"%s\"", escaped)
}

// emit_post_load_hook executes post-load hooks with safety checks
emit_post_load_hook :: proc(module: manifest.Module) {
    if len(module.hooks.post_load) == 0 {
        return
    }
    
    fmt.printf("# Post-load hook for %s\n", module.name)
    
    // Safety check: verify the function exists before calling it
    hook_name := strings.trim_space(module.hooks.post_load)
    
    // Validate hook name contains only safe characters
    if !is_safe_hook_name(hook_name) {
        fmt.printf("# WARNING: Skipping unsafe post-load hook name: %s\n", hook_name)
        fmt.println()
        return
    }
    
    fmt.printf("if typeset -f %s >/dev/null 2>&1; then\n", hook_name)
    fmt.printf("    %s\n", hook_name)
    fmt.printf("else\n")
    fmt.printf("    echo \"Warning: Post-load hook '%s' not found for module %s\" >&2\n", hook_name, module.name)
    fmt.printf("fi\n")
    fmt.println()
}

// emit_module_separator adds visual separation between modules
emit_module_separator :: proc() {
    separator := strings.repeat("=", 60, context.temp_allocator)
    fmt.printf("# %s\n", separator)
    fmt.println()
}