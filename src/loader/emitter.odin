package loader

import "core:fmt"
import "core:time"
import "core:strings"
import "core:path/filepath"
import "../manifest"

_emit_config: Shell_Config

set_emit_config :: proc(config: Shell_Config) {
    _emit_config = config
    reset_shell_backend_cache()
}

get_emit_config :: proc() -> Shell_Config {
    return _emit_config
}

emit :: proc(modules: [dynamic]manifest.Module) {
    if len(modules) > 20 {
        emit_batch_optimized(modules)
    } else {
        emit_standard(modules)
    }
}

// emit_standard generates shell code using the standard approach
emit_standard :: proc(modules: [dynamic]manifest.Module) {
    emit_header(len(modules))
    
    for module in modules {
        emit_module(module)
    }
}

// emit_batch_optimized generates shell code using batch string building for better performance
emit_batch_optimized :: proc(modules: [dynamic]manifest.Module) {
    builder := create_batch_string_builder(8192) // 8KB initial chunk size
    defer destroy_batch_string_builder(&builder)
    
    // Build header
    header := fmt.tprintf("# Generated by Zephyr Shell Loader\n# https://github.com/xDarkicex/zephyr\n# Generated: %v\n# Total modules: %d\n#\n# This file is auto-generated. Do not edit manually.\n# To regenerate, run: zephyr load\n\n", 
                         time.now(), len(modules))
    batch_write_string(&builder, header)
    session_code := build_session_registration_code()
    batch_write_string(&builder, session_code)
    
    // Build module code in batches
    for module in modules {
        module_code := build_module_code(module)
        batch_write_string(&builder, module_code)
    }
    
    // Output the complete result
    result := batch_build_string(&builder)
    fmt.print(result)
}

// build_module_code builds the complete shell code for a single module
build_module_code :: proc(module: manifest.Module) -> string {
    builder := create_batch_string_builder(1024) // 1KB for single module
    defer destroy_batch_string_builder(&builder)
    
    // Module header
    header := fmt.tprintf("# === Module: %s v%s ===\n", module.name, module.version)
    batch_write_string(&builder, header)
    
    if len(module.description) > 0 {
        desc := fmt.tprintf("# %s\n", module.description)
        batch_write_string(&builder, desc)
    }
    
    if len(module.author) > 0 {
        author := fmt.tprintf("# Author: %s\n", module.author)
        batch_write_string(&builder, author)
    }
    
    batch_write_string(&builder, "\n")
    
    // Settings
    if len(module.settings) > 0 {
        settings_header := fmt.tprintf("# Settings for %s\n", module.name)
        batch_write_string(&builder, settings_header)
        
        for key, value in module.settings {
            setting_code := build_setting_export(module.name, key, value)
            batch_write_string(&builder, setting_code)
        }
        
        batch_write_string(&builder, "\n")
    }
    
    // Pre-load hook
    if len(module.hooks.pre_load) > 0 {
        hook_code := build_pre_load_hook(module)
        batch_write_string(&builder, hook_code)
    }
    
    // Source files
    if len(module.files) > 0 {
        files_header := fmt.tprintf("# Source files for %s\n", module.name)
        batch_write_string(&builder, files_header)
        
        for file in module.files {
            file_code := build_source_file_code(module.path, file)
            batch_write_string(&builder, file_code)
        }
        
        batch_write_string(&builder, "\n")
    }
    
    // Post-load hook
    if len(module.hooks.post_load) > 0 {
        hook_code := build_post_load_hook(module)
        batch_write_string(&builder, hook_code)
    }
    
    // Module separator
    separator := fmt.tprintf("# %s\n\n", strings.repeat("=", 60, context.temp_allocator))
    batch_write_string(&builder, separator)
    
    return batch_build_string(&builder)
}

// build_setting_export builds the export statement for a module setting
build_setting_export :: proc(module_name, key, value: string) -> string {
    module_name_upper := strings.to_upper(module_name, context.temp_allocator)
    key_upper := strings.to_upper(key, context.temp_allocator)
    
    // Clean module name and key
    clean_module_name := make([]u8, len(module_name_upper), context.temp_allocator)
    copy(clean_module_name, module_name_upper)
    for i in 0..<len(clean_module_name) {
        if clean_module_name[i] < 'A' || clean_module_name[i] > 'Z' {
            if clean_module_name[i] < '0' || clean_module_name[i] > '9' {
                clean_module_name[i] = '_'
            }
        }
    }
    
    clean_key := make([]u8, len(key_upper), context.temp_allocator)
    copy(clean_key, key_upper)
    for i in 0..<len(clean_key) {
        if clean_key[i] < 'A' || clean_key[i] > 'Z' {
            if clean_key[i] < '0' || clean_key[i] > '9' {
                clean_key[i] = '_'
            }
        }
    }
    
    env_var := fmt.tprintf("ZSH_MODULE_%s_%s", string(clean_module_name), string(clean_key))
    escaped_value := escape_shell_value(value)
    
    return fmt.tprintf("export %s=%s\n", env_var, escaped_value)
}

// build_pre_load_hook builds the pre-load hook code
build_pre_load_hook :: proc(module: manifest.Module) -> string {
    hook_name := strings.trim_space(module.hooks.pre_load)
    
    if !is_safe_hook_name(hook_name) {
        return fmt.tprintf("# WARNING: Skipping unsafe pre-load hook name: %s\n\n", hook_name)
    }
    
    backend := get_shell_backend(&_emit_config)
    fn_check := backend.function_exists_check(hook_name)
    
    return fmt.tprintf("# Pre-load hook for %s\nif %s >/dev/null 2>&1; then\n    %s\nelse\n    echo \"Warning: Pre-load hook '%s' not found for module %s\" >&2\nfi\n\n", 
                      module.name, fn_check, hook_name, hook_name, module.name)
}

// build_post_load_hook builds the post-load hook code
build_post_load_hook :: proc(module: manifest.Module) -> string {
    hook_name := strings.trim_space(module.hooks.post_load)
    
    if !is_safe_hook_name(hook_name) {
        return fmt.tprintf("# WARNING: Skipping unsafe post-load hook name: %s\n\n", hook_name)
    }
    
    backend := get_shell_backend(&_emit_config)
    fn_check := backend.function_exists_check(hook_name)
    
    return fmt.tprintf("# Post-load hook for %s\nif %s >/dev/null 2>&1; then\n    %s\nelse\n    echo \"Warning: Post-load hook '%s' not found for module %s\" >&2\nfi\n\n", 
                      module.name, fn_check, hook_name, hook_name, module.name)
}

// build_source_file_code builds the source file code
build_source_file_code :: proc(module_path, file: string) -> string {
    full_path := filepath.join({module_path, file})
    quoted_path := quote_shell_path(full_path)
    
    result := fmt.tprintf("if [[ -f %s ]]; then\n    source %s\nelse\n    echo \"Warning: Module file not found: %s\" >&2\nfi\n", 
                         quoted_path, quoted_path, quoted_path)

    if full_path != "" {
        delete(full_path)
    }

    return result
}

// emit_header generates header comments with metadata
emit_header :: proc(module_count: int) {
    fmt.println("# Generated by Zephyr Shell Loader")
    fmt.println("# https://github.com/xDarkicex/zephyr")
    
    // Get current timestamp
    now := time.now()
    // Format timestamp manually since to_string might not be available
    fmt.printf("# Generated: %v\n", now)
    
    fmt.printf("# Total modules: %d\n", module_count)
    fmt.println("#")
    fmt.println("# This file is auto-generated. Do not edit manually.")
    fmt.println("# To regenerate, run: zephyr load")
    fmt.println()
    fmt.print(build_session_registration_code())
}

// emit_module generates shell code for a single module
emit_module :: proc(module: manifest.Module) {
    emit_module_header(module)
    emit_module_settings(module)
    emit_pre_load_hook(module)
    emit_module_files(module)
    emit_post_load_hook(module)
    emit_module_separator()
}

build_session_registration_code :: proc() -> string {
    return `# Agent session registration
detect_agent_type() {
    if [[ -n "$ANTHROPIC_API_KEY" ]] || [[ -n "$ANTHROPIC_AGENT_ID" ]]; then
        echo "claude-code"
    elif [[ "$TERM_PROGRAM" == "cursor" ]] || [[ -n "$CURSOR_AGENT_ID" ]]; then
        echo "cursor"
    elif [[ -n "$GITHUB_COPILOT_TOKEN" ]] || [[ -n "$GITHUB_COPILOT_SESSION" ]]; then
        echo "github-copilot"
    elif [[ "$TERM_PROGRAM" == "vscode" ]]; then
        echo "vscode"
    elif [[ -n "$WINDSURF_SESSION" ]] || [[ "$TERM_PROGRAM" == "windsurf" ]]; then
        echo "windsurf"
    elif [[ -n "$AIDER_SESSION" ]]; then
        echo "aider"
    else
        echo "human"
    fi
}

get_agent_id() {
    local agent_type="$1"
    case "$agent_type" in
        claude-code)
            echo "${ANTHROPIC_AGENT_ID:-${USER}}"
            ;;
        cursor)
            echo "${CURSOR_AGENT_ID:-${USER}}"
            ;;
        github-copilot)
            echo "${GITHUB_COPILOT_SESSION:-${USER}}"
            ;;
        windsurf)
            echo "${WINDSURF_SESSION:-${USER}}"
            ;;
        aider)
            echo "${AIDER_SESSION:-${USER}}"
            ;;
        *)
            echo "${USER}"
            ;;
    esac
}

ZEPHYR_AGENT_TYPE="$(detect_agent_type)"
ZEPHYR_AGENT_ID="$(get_agent_id "$ZEPHYR_AGENT_TYPE")"
ZEPHYR_SESSION_ID="$$"
ZEPHYR_PARENT_PROCESS="$(ps -o comm= -p $PPID 2>/dev/null || echo 'unknown')"

export ZEPHYR_AGENT_ID
export ZEPHYR_AGENT_TYPE
export ZEPHYR_SESSION_ID

if command -v zephyr >/dev/null 2>&1; then
    zephyr register-session \
        --agent-id="$ZEPHYR_AGENT_ID" \
        --agent-type="$ZEPHYR_AGENT_TYPE" \
        --session-id="$ZEPHYR_SESSION_ID" \
        --parent="$ZEPHYR_PARENT_PROCESS" >/dev/null 2>&1
fi

`
}

// emit_module_header generates module separation comments
emit_module_header :: proc(module: manifest.Module) {
    fmt.printf("# === Module: %s v%s ===\n", module.name, module.version)
    if len(module.description) > 0 {
        fmt.printf("# %s\n", module.description)
    }
    if len(module.author) > 0 {
        fmt.printf("# Author: %s\n", module.author)
    }
    fmt.println()
}

// emit_module_settings exports module settings as ZSH_MODULE_* environment variables
emit_module_settings :: proc(module: manifest.Module) {
    if len(module.settings) == 0 {
        return
    }
    
    fmt.printf("# Settings for %s\n", module.name)
    
    for key, value in module.settings {
        // Convert module name and setting key to uppercase for environment variable
        module_name_upper := strings.to_upper(module.name, context.temp_allocator)
        key_upper := strings.to_upper(key, context.temp_allocator)
        
        // Replace any non-alphanumeric characters with underscores in module name
        clean_module_name := make([]u8, len(module_name_upper), context.temp_allocator)
        copy(clean_module_name, module_name_upper)
        for i in 0..<len(clean_module_name) {
            if clean_module_name[i] < 'A' || clean_module_name[i] > 'Z' {
                if clean_module_name[i] < '0' || clean_module_name[i] > '9' {
                    clean_module_name[i] = '_'
                }
            }
        }
        
        // Replace any non-alphanumeric characters with underscores in key
        clean_key := make([]u8, len(key_upper), context.temp_allocator)
        copy(clean_key, key_upper)
        for i in 0..<len(clean_key) {
            if clean_key[i] < 'A' || clean_key[i] > 'Z' {
                if clean_key[i] < '0' || clean_key[i] > '9' {
                    clean_key[i] = '_'
                }
            }
        }
        
        env_var := fmt.tprintf("ZSH_MODULE_%s_%s", string(clean_module_name), string(clean_key))
        
        // Properly escape the value for shell
        escaped_value := escape_shell_value(value)
        fmt.printf("export %s=%s\n", env_var, escaped_value)
    }
    
    fmt.println()
}

// escape_shell_value properly escapes a value for safe use in shell export
escape_shell_value :: proc(value: string) -> string {
    // For safety, always quote values and escape any quotes within
    escaped, _ := strings.replace_all(value, "\"", "\\\"", context.temp_allocator)
    return fmt.tprintf("\"%s\"", escaped)
}

// emit_pre_load_hook executes pre-load hooks with safety checks
emit_pre_load_hook :: proc(module: manifest.Module) {
    if len(module.hooks.pre_load) == 0 {
        return
    }
    
    fmt.printf("# Pre-load hook for %s\n", module.name)
    
    hook_name := strings.trim_space(module.hooks.pre_load)
    
    if !is_safe_hook_name(hook_name) {
        fmt.printf("# WARNING: Skipping unsafe pre-load hook name: %s\n", hook_name)
        fmt.println()
        return
    }
    
    backend := get_shell_backend(&_emit_config)
    fn_check := backend.function_exists_check(hook_name)
    
    fmt.printf("if %s >/dev/null 2>&1; then\n", fn_check)
    fmt.printf("    %s\n", hook_name)
    fmt.printf("else\n")
    fmt.printf("    echo \"Warning: Pre-load hook '%s' not found for module %s\" >&2\n", hook_name, module.name)
    fmt.printf("fi\n")
    fmt.println()
}

// is_safe_hook_name validates that a hook name contains only safe characters
is_safe_hook_name :: proc(name: string) -> bool {
    if len(name) == 0 {
        return false
    }
    
    // Hook names should only contain alphanumeric characters, underscores, and dashes
    // and should not start with a dash
    if name[0] == '-' {
        return false
    }
    
    for char in name {
        if !((char >= 'a' && char <= 'z') || 
             (char >= 'A' && char <= 'Z') || 
             (char >= '0' && char <= '9') || 
             char == '_' || char == '-') {
            return false
        }
    }
    
    return true
}

// emit_module_files sources all specified module files with proper path quoting
emit_module_files :: proc(module: manifest.Module) {
    if len(module.files) == 0 {
        return
    }
    
    fmt.printf("# Source files for %s\n", module.name)
    
    for file in module.files {
        // Construct full path to the file
        full_path := filepath.join({module.path, file})
        
        // Properly quote the path to handle spaces and special characters
        quoted_path := quote_shell_path(full_path)
        
        // Add existence check before sourcing
        fmt.printf("if [[ -f %s ]]; then\n", quoted_path)
        fmt.printf("    source %s\n", quoted_path)
        fmt.printf("else\n")
        fmt.printf("    echo \"Warning: Module file not found: %s\" >&2\n", quoted_path)
        fmt.printf("fi\n")

        if full_path != "" {
            delete(full_path)
        }
    }
    
    fmt.println()
}

// quote_shell_path properly quotes a file path for safe use in shell commands
quote_shell_path :: proc(path: string) -> string {
    // Use double quotes and escape any double quotes, backslashes, and dollar signs in the path
    escaped := path
    escaped, _ = strings.replace_all(escaped, "\\", "\\\\", context.temp_allocator)
    escaped, _ = strings.replace_all(escaped, "\"", "\\\"", context.temp_allocator)
    escaped, _ = strings.replace_all(escaped, "$", "\\$", context.temp_allocator)
    escaped, _ = strings.replace_all(escaped, "`", "\\`", context.temp_allocator)
    
    return fmt.tprintf("\"%s\"", escaped)
}

// emit_post_load_hook executes post-load hooks with safety checks
emit_post_load_hook :: proc(module: manifest.Module) {
    if len(module.hooks.post_load) == 0 {
        return
    }
    
    fmt.printf("# Post-load hook for %s\n", module.name)
    
    hook_name := strings.trim_space(module.hooks.post_load)
    
    if !is_safe_hook_name(hook_name) {
        fmt.printf("# WARNING: Skipping unsafe post-load hook name: %s\n", hook_name)
        fmt.println()
        return
    }
    
    backend := get_shell_backend(&_emit_config)
    fn_check := backend.function_exists_check(hook_name)
    
    fmt.printf("if %s >/dev/null 2>&1; then\n", fn_check)
    fmt.printf("    %s\n", hook_name)
    fmt.printf("else\n")
    fmt.printf("    echo \"Warning: Post-load hook '%s' not found for module %s\" >&2\n", hook_name, module.name)
    fmt.printf("fi\n")
    fmt.println()
}

// emit_module_separator adds visual separation between modules
emit_module_separator :: proc() {
    separator := strings.repeat("=", 60, context.temp_allocator)
    fmt.printf("# %s\n", separator)
    fmt.println()
}
