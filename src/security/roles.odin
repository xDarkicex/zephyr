package security

import "core:os"
import "core:strings"
import "core:path/filepath"
import "core:strconv"
import "core:os/os2"

import "../manifest"

load_security_config :: proc() -> Security_Config {
	config_path := get_security_config_path()
	defer delete(config_path)

	if !os.exists(config_path) {
		return get_default_security_config()
	}

	sections, ok := manifest.parse_toml_sections(config_path)
	if !ok {
		return get_default_security_config()
	}
	defer manifest.delete_toml_sections(sections)

	return parse_security_config(sections)
}

parse_security_config :: proc(m: manifest.Toml_Sections) -> Security_Config {
	config := Security_Config{roles = make(map[string]Role_Config)}

	for section, pairs in m {
		if !strings.has_prefix(section, "roles.") {
			continue
		}
		role_name := strings.trim_prefix(section, "roles.")
		config.roles[role_name] = parse_role_config(pairs)
	}

	if len(config.roles) == 0 {
		return get_default_security_config()
	}

	return config
}

parse_role_config :: proc(pairs: map[string]string) -> Role_Config {
	role := Role_Config{}
	role.can_install = parse_bool(pairs["can_install"], true)
	role.can_install_unsigned = parse_bool(pairs["can_install_unsigned"], true)
	role.can_use_unsafe = parse_bool(pairs["can_use_unsafe"], true)
	role.can_uninstall = parse_bool(pairs["can_uninstall"], true)
	role.can_modify_config = parse_bool(pairs["can_modify_config"], true)
	role.require_confirmation = parse_bool(pairs["require_confirmation"], false)
	return role
}

parse_bool :: proc(value: string, fallback: bool) -> bool {
	if value == "" {
		return fallback
	}
	parsed, ok := strconv.parse_bool(value)
	if !ok {
		return fallback
	}
	return parsed
}

get_default_security_config :: proc() -> Security_Config {
	config := Security_Config{roles = make(map[string]Role_Config)}

	config.roles["user"] = Role_Config{
		can_install          = true,
		can_install_unsigned = true,
		can_use_unsafe       = true,
		can_uninstall        = true,
		can_modify_config    = true,
		require_confirmation = false,
	}

	config.roles["agent"] = Role_Config{
		can_install          = true,
		can_install_unsigned = false,
		can_use_unsafe       = false,
		can_uninstall        = false,
		can_modify_config    = false,
		require_confirmation = true,
	}

	config.roles["admin"] = Role_Config{
		can_install          = true,
		can_install_unsigned = true,
		can_use_unsafe       = true,
		can_uninstall        = true,
		can_modify_config    = true,
		require_confirmation = false,
	}

	return config
}

load_role_config :: proc(role: string) -> Role_Config {
	config := load_security_config()
	if role_config, ok := config.roles[role]; ok {
		delete(config.roles)
		return role_config
	}
	fallback := config.roles["agent"]
	delete(config.roles)
	return fallback
}

get_security_config_path :: proc() -> string {
	home := os.get_env("HOME")
	defer delete(home)
	if home == "" {
		return ""
	}
	return filepath.join({home, ".zephyr", "security.toml"})
}

create_default_security_config :: proc() {
	config_path := get_security_config_path()
	if config_path == "" {
		return
	}
	defer delete(config_path)

	config_dir := filepath.dir(config_path)
	defer delete(config_dir)
	if !ensure_directory(config_dir) {
		return
	}

	config_toml := `# Zephyr Security Configuration
# Generated by setup wizard

[roles.user]
# Human users have full control
can_install = true
can_install_unsigned = true
can_use_unsafe = true
can_uninstall = true
can_modify_config = true
require_confirmation = false

[roles.agent]
# AI agents have restricted permissions
can_install = true
can_install_unsigned = false  # Only signed modules
can_use_unsafe = false        # Never allow --unsafe
can_uninstall = false         # Prevent accidental removal
can_modify_config = false     # Prevent config tampering
require_confirmation = true   # Prompt user for dangerous ops

[roles.admin]
# Admin role for automation/CI
can_install = true
can_install_unsigned = true
can_use_unsafe = true
can_uninstall = true
can_modify_config = true
require_confirmation = false
`

	_ = os.write_entire_file(config_path, transmute([]byte)config_toml)
}
