package cli

import "core:fmt"
import "core:os"
import "core:path/filepath"
import "core:strings"

import "../colors"
import "../git"

setup_already_done :: proc() -> bool {
	config_path := get_config_path()
	defer delete(config_path)
	if config_path == "" {
		return true
	}
	return os.exists(config_path)
}

get_config_path :: proc() -> string {
	home := os.get_env("HOME")
	defer delete(home)
	if home == "" {
		return ""
	}
	return filepath.join({home, ".zephyr", "config.toml"})
}

create_config_file :: proc() {
	config_path := get_config_path()
	if config_path == "" {
		return
	}
	defer delete(config_path)

	config_dir := filepath.dir(config_path)
	if config_dir == "" {
		return
	}
	defer delete(config_dir)

	if !os.exists(config_dir) {
		os.make_directory(config_dir, 0o755)
	}
	if !os.exists(config_dir) {
		return
	}

	config := `# Zephyr Configuration
# Generated by setup wizard

[core]
setup_complete = true
`
	os.write_entire_file(config_path, transmute([]u8)config)
}

run_first_time_setup :: proc() {
	if setup_already_done() {
		return
	}

	fmt.println("")
	fmt.println(colors.bold("Welcome to Zephyr!"))
	fmt.println("")
	fmt.println("Zephyr modules execute with full shell privileges.")
	fmt.println("For safety with AI assistants, we recommend the 'guardrails' module.")
	fmt.println("")
	fmt.println(fmt.tprintf("%s (cryptographically signed):", colors.bold("Guardrails module")))
	fmt.println("  • Replaces 'rm' with 'trash' (reversible deletion)")
	fmt.println("  • Blocks dangerous commands like 'dd'")
	fmt.println("  • Protects sensitive files from AI access")
	fmt.println("")

	if prompt_yes_no("Install guardrails module?", true) {
		fmt.println("")
		fmt.println("> Downloading signed module...")
		if !git.libgit2_enabled() {
			fmt.println(fmt.tprintf("%s Git support not available; skipping guardrails install.", colors.warning_symbol()))
		} else {
			init_result := git.init_libgit2()
			defer git.cleanup_git_result(&init_result)
			if !init_result.success {
				fmt.println(fmt.tprintf("%s Failed to initialize git: %s", colors.error_symbol(), init_result.message))
			} else {
				defer {
					shutdown_result := git.shutdown_libgit2()
					defer git.cleanup_git_result(&shutdown_result)
				}
				options := git.Manager_Options{
					verbose = false,
					force = false,
					confirm = false,
					allow_local = false,
					check_dependencies = false,
					unsafe = false,
				}
				success, msg := git.install_module("xDarkicex/zephyr-guardrails-module", options)
				if success {
					fmt.println(fmt.tprintf("%s Guardrails installed successfully!", colors.success_symbol()))
					fmt.println("")
					fmt.println("Note: Install trash-cli for full protection:")
					fmt.println("  macOS:  brew install trash-cli")
					fmt.println("  Linux:  apt-get install trash-cli")
				} else {
					fmt.println(fmt.tprintf("%s Failed to install guardrails: %s", colors.error_symbol(), msg))
				}
				if msg != "" {
					delete(msg)
				}
			}
		}
	}

	fmt.println("")
	fmt.println("Setup complete! Run 'zephyr list' to see your modules.")
	fmt.println("")

	create_config_file()
}

prompt_yes_no :: proc(question: string, default_yes: bool) -> bool {
	prompt := question
	if default_yes {
		prompt = fmt.tprintf("%s [Y/n]: ", question)
	} else {
		prompt = fmt.tprintf("%s [y/N]: ", question)
	}

	fmt.print(prompt)

	buffer: [256]byte
	n, err := os.read(os.stdin, buffer[:])
	if err != os.ERROR_NONE {
		return default_yes
	}

	response := strings.trim_space(string(buffer[:n]))
	if response == "" {
		return default_yes
	}
	lower := strings.to_lower(response)
	defer delete(lower)
	return lower == "y" || lower == "yes"
}
