package cli

import "core:fmt"
import "core:os"
import "core:path/filepath"
import "core:strings"

import "../colors"
import "../git"

setup_already_done :: proc() -> bool {
	config_path := get_config_path()
	defer delete(config_path)
	if config_path == "" {
		return true
	}
	return os.exists(config_path)
}

get_config_path :: proc() -> string {
	home := os.get_env("HOME")
	defer delete(home)
	if home == "" {
		return ""
	}
	return filepath.join({home, ".zephyr", "config.toml"})
}

create_config_file :: proc() {
	config_path := get_config_path()
	if config_path == "" {
		return
	}
	defer delete(config_path)

	config_dir := filepath.dir(config_path)
	if config_dir == "" {
		return
	}
	defer delete(config_dir)

	if !os.exists(config_dir) {
		os.make_directory(config_dir, 0o755)
	}
	if !os.exists(config_dir) {
		return
	}

	config := `# Zephyr Configuration
# Generated by setup wizard

[core]
setup_complete = true
`
	os.write_entire_file(config_path, transmute([]u8)config)
}

run_first_time_setup :: proc() {
	if setup_already_done() {
		return
	}

	fmt.println("")
	fmt.println(colors.bold("Welcome to Zephyr!"))
	fmt.println("")
	fmt.println("Zephyr modules execute with full shell privileges.")
	fmt.println("For safety with AI assistants, we recommend the 'guardrails' module.")
	fmt.println("")
	fmt.println(colors.bold("Guardrails module") + " (cryptographically signed):")
	fmt.println("  • Replaces 'rm' with 'trash' (reversible deletion)")
	fmt.println("  • Blocks dangerous commands like 'dd'")
	fmt.println("  • Protects sensitive files from AI access")
	fmt.println("")

	if prompt_yes_no("Install guardrails module?", true) {
		fmt.println("")
		fmt.println("> Downloading signed module...")
		options := git.Manager_Options{
			verbose = false,
			force = false,
			confirm = false,
			allow_local = false,
			check_dependencies = false,
			unsafe = false,
		}
		success, msg := git.install_module("xDarkicex/zephyr-guardrails-module", options)
		if success {
			fmt.println(colors.green("✓") + " Guardrails installed successfully!")
			fmt.println("")
			fmt.println("Note: Install trash-cli for full protection:")
			fmt.println("  macOS:  brew install trash-cli")
			fmt.println("  Linux:  apt-get install trash-cli")
		} else {
			fmt.println(colors.red("✗") + " Failed to install guardrails: " + msg)
		}
	}

	fmt.println("")
	fmt.println("Setup complete! Run 'zephyr list' to see your modules.")
	fmt.println("")

	create_config_file()
}

prompt_yes_no :: proc(question: string, default_yes: bool) -> bool {
	prompt := question
	if default_yes {
		prompt += " [Y/n]: "
	} else {
		prompt += " [y/N]: "
	}

	fmt.print(prompt)

	buffer: [256]byte
	n, err := os.read(os.stdin, buffer[:])
	if err != os.ERROR_NONE {
		return default_yes
	}

	response := strings.trim_space(string(buffer[:n]))
	if response == "" {
		return default_yes
	}
	lower := strings.to_lower(response)
	defer delete(lower)
	return lower == "y" || lower == "yes"
}
