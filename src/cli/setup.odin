package cli

import "core:fmt"
import "core:os"
import "core:path/filepath"
import "core:strings"

import "../colors"
import "../git"
import "../security"

setup_already_done :: proc() -> bool {
	config_path := get_config_path()
	defer delete(config_path)
	if config_path == "" {
		return true
	}
	return os.exists(config_path)
}

get_config_path :: proc() -> string {
	home := os.get_env("HOME")
	defer delete(home)
	if home == "" {
		return ""
	}
	return filepath.join({home, ".zephyr", "config.toml"})
}

create_config_file :: proc() {
	if !security.require_permission(.Modify_Config, "modify configuration") {
		security.log_config_modify(false, "permission denied")
		return
	}
	config_path := get_config_path()
	if config_path == "" {
		security.log_config_modify(false, "config path unavailable")
		return
	}
	defer delete(config_path)

	config_dir := filepath.dir(config_path)
	if config_dir == "" {
		security.log_config_modify(false, "config directory unavailable")
		return
	}
	defer delete(config_dir)

	if !os.exists(config_dir) {
		os.make_directory(config_dir, 0o755)
	}
	if !os.exists(config_dir) {
		security.log_config_modify(false, "failed to create config directory")
		return
	}

	config := `# Zephyr Configuration
# Generated by setup wizard

[core]
setup_complete = true
`
	success := os.write_entire_file(config_path, transmute([]u8)config)
	if success {
		security.log_config_modify(true, "config written")
	} else {
		security.log_config_modify(false, "failed to write config")
	}
}

// Create_Config_File_For_Test exposes config creation for integration tests.
Create_Config_File_For_Test :: proc() {
	create_config_file()
}

run_first_time_setup :: proc() {
	if setup_already_done() {
		return
	}

	fmt.println("")
	fmt.println(colors.bold("Welcome to Zephyr!"))
	fmt.println("")
	fmt.println("Zephyr modules execute with full shell privileges.")
	fmt.println("For safety with AI assistants, we recommend the 'guardrails' module.")
	fmt.println("")
	fmt.println(fmt.tprintf("%s (cryptographically signed):", colors.bold("Guardrails module")))
	fmt.println("  • Replaces 'rm' with 'trash' (reversible deletion)")
	fmt.println("  • Blocks dangerous commands like 'dd'")
	fmt.println("  • Protects sensitive files from AI access")
	fmt.println("")

	if prompt_yes_no("Install guardrails module?", true) {
		fmt.println("")
		fmt.println("> Downloading signed module...")
		if !git.libgit2_enabled() {
			fmt.println(fmt.tprintf("%s Git support not available; skipping guardrails install.", colors.warning_symbol()))
		} else {
			init_result := git.init_libgit2()
			defer git.cleanup_git_result(&init_result)
			if !init_result.success {
				fmt.println(fmt.tprintf("%s Failed to initialize git: %s", colors.error_symbol(), init_result.message))
			} else {
				defer {
					shutdown_result := git.shutdown_libgit2()
					defer git.cleanup_git_result(&shutdown_result)
				}
				options := git.Manager_Options{
					verbose = false,
					force = false,
					confirm = false,
					allow_local = false,
					check_dependencies = false,
					unsafe = false,
				}
				success, msg := git.install_module("zephyr-systems/zephyr-guardrails-module", options)
				if success {
					fmt.println(fmt.tprintf("%s Guardrails installed successfully!", colors.success_symbol()))
					fmt.println("")
					fmt.println("Note: Install trash-cli for full protection:")
					fmt.println("  macOS:  brew install trash-cli")
					fmt.println("  Linux:  apt-get install trash-cli")
				} else {
					fmt.println(fmt.tprintf("%s Failed to install guardrails: %s", colors.error_symbol(), msg))
				}
				if msg != "" {
					delete(msg)
				}
			}
		}
	}

	fmt.println("")
	fmt.println("Setup complete! Run 'zephyr list' to see your modules.")
	fmt.println("")

	create_config_file()

	run_agent_roles_setup()
}

prompt_yes_no :: proc(question: string, default_yes: bool) -> bool {
	prompt := question
	if default_yes {
		prompt = fmt.tprintf("%s [Y/n]: ", question)
	} else {
		prompt = fmt.tprintf("%s [y/N]: ", question)
	}

	fmt.print(prompt)

	buffer: [256]byte
	n, err := os.read(os.stdin, buffer[:])
	if err != os.ERROR_NONE {
		return default_yes
	}

	response := strings.trim_space(string(buffer[:n]))
	if response == "" {
		return default_yes
	}
	lower := strings.to_lower(response)
	defer delete(lower)
	return lower == "y" || lower == "yes"
}

run_agent_roles_setup :: proc() {
	fmt.println("")
	fmt.println(colors.bold("Agent Permissions"))
	fmt.println("")
	fmt.println("Zephyr can enforce permissions for AI agents (install, uninstall, config).")
	fmt.println("This creates ~/.zephyr/security.toml with default roles for user/agent/admin.")
	fmt.println("")

	if prompt_yes_no("Configure agent permissions?", true) {
		security.create_default_security_config()
		fmt.println("")
		fmt.println("Agent permissions configured.")
	} else {
		fmt.println("")
		fmt.println("Skipped agent permissions setup.")
	}

	session, ok := security.get_current_session()
	if ok {
		fmt.println("")
		fmt.println("Current session:")
		fmt.printf("  Agent: %s (%s)\n", session.agent_id, session.agent_type)
		fmt.printf("  Role: %s\n", session.role)
		fmt.printf("  Session ID: %s\n", session.session_id)
	}
}
