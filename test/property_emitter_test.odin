#+feature dynamic-literals
package test

import "core:testing"
import "core:fmt"
import "core:strings"
import "core:os"

import "../src/loader"
import "../src/manifest"

// Simple counter for generating unique test data
emitter_test_counter := 0

// Generate a unique identifier
generate_unique_id :: proc() -> int {
    emitter_test_counter += 1
    return emitter_test_counter
}

// Generate a simple module for shell code testing
generate_shell_test_module :: proc(name: string, priority: int, has_hooks: bool, has_settings: bool, has_files: bool) -> manifest.Module {
    module := manifest.Module{
        name = strings.clone(name),
        version = strings.clone("1.0.0"),
        description = strings.clone("Test module for shell code generation"),
        author = strings.clone("Test Author"),
        license = strings.clone("MIT"),
        priority = priority,
        required = make([dynamic]string),
        optional = make([dynamic]string),
        files = make([dynamic]string),
        settings = make(map[string]string),
        platforms = manifest.Platform_Filter{
            os = make([dynamic]string),
            arch = make([dynamic]string),
        },
        path = strings.clone(fmt.tprintf("/test/modules/%s", name)),
    }
    
    if has_hooks {
        module.hooks.pre_load = strings.clone("test_pre_hook")
        module.hooks.post_load = strings.clone("test_post_hook")
    }
    
    if has_settings {
        manifest.AddSetting(&module, "debug", "true")
        manifest.AddSetting(&module, "timeout", "30")
        manifest.AddSetting(&module, "log_level", "info")
    }
    
    if has_files {
        append(&module.files, strings.clone("init.zsh"))
        append(&module.files, strings.clone("functions.zsh"))
    }
    
    return module
}

// Generate modules with special characters in names and paths
generate_special_char_module :: proc(base_name: string, special_suffix: string) -> manifest.Module {
    name := fmt.tprintf("%s%s", base_name, special_suffix)
    module := manifest.Module{
        name = strings.clone(name),
        version = strings.clone("1.0.0"),
        priority = 50,
        required = make([dynamic]string),
        optional = make([dynamic]string),
        files = make([dynamic]string),
        settings = make(map[string]string),
        platforms = manifest.Platform_Filter{
            os = make([dynamic]string),
            arch = make([dynamic]string),
        },
        path = strings.clone(fmt.tprintf("/test/path with spaces/%s", name)),
    }
    
    // Add files with special characters
    append(&module.files, strings.clone("file with spaces.zsh"))
    append(&module.files, strings.clone("file$with$dollars.zsh"))
    
    // Add settings with special characters
    manifest.AddSetting(&module, "key-with-dashes", "value with spaces")
    manifest.AddSetting(&module, "key_with_underscores", "value\"with\"quotes")
    manifest.AddSetting(&module, "key$with$dollars", "value$with$dollars")
    
    return module
}

// Check if generated shell code contains basic syntax elements
check_shell_syntax_basics :: proc(t: ^testing.T, output: string, test_name: string) {
    // Property: Generated code should contain header comments
    testing.expect(t, strings.contains(output, "# Generated by Zephyr Shell Loader"), 
        fmt.tprintf("%s: Should contain header comment", test_name))
    
    // Property: Generated code should not contain obvious syntax errors
    testing.expect(t, !strings.contains(output, "export ="), 
        fmt.tprintf("%s: Should not contain malformed export statements", test_name))
    
    // Property: All quotes should be properly paired
    quote_count := 0
    for char in output {
        if char == '"' {
            quote_count += 1
        }
    }
    testing.expect(t, quote_count % 2 == 0, 
        fmt.tprintf("%s: All quotes should be properly paired (found %d quotes)", test_name, quote_count))
}

// Check environment variable naming conventions
check_env_var_naming :: proc(t: ^testing.T, output: string, module_name: string, test_name: string) {
    // Property: Environment variables should follow ZSH_MODULE_* convention
    lines := strings.split_lines(output)
    defer delete(lines)
    
    for line in lines {
        if strings.contains(line, "export") && strings.contains(line, "=") {
            // Extract the variable name
            parts := strings.split(line, "=")
            defer delete(parts)
            
            if len(parts) >= 2 {
                export_part := strings.trim_space(parts[0])
                if strings.has_prefix(export_part, "export ") {
                    var_name := strings.trim_space(export_part[7:]) // Remove "export "
                    
                    // Property: Should start with ZSH_MODULE_
                    testing.expect(t, strings.has_prefix(var_name, "ZSH_MODULE_"), 
                        fmt.tprintf("%s: Environment variable '%s' should start with ZSH_MODULE_", test_name, var_name))
                    
                    // Property: Should contain the module name (converted to uppercase)
                    module_upper := strings.to_upper(module_name, context.temp_allocator)
                    testing.expect(t, strings.contains(var_name, module_upper), 
                        fmt.tprintf("%s: Environment variable '%s' should contain module name '%s'", test_name, var_name, module_upper))
                }
            }
        }
    }
}

// Check hook safety patterns
check_hook_safety :: proc(t: ^testing.T, output: string, test_name: string) {
    // Property: Hooks should include safety checks
    if strings.contains(output, "test_pre_hook") || strings.contains(output, "test_post_hook") {
        testing.expect(t, strings.contains(output, "typeset -f"), 
            fmt.tprintf("%s: Hook execution should include function existence check", test_name))
        
        testing.expect(t, strings.contains(output, ">/dev/null 2>&1"), 
            fmt.tprintf("%s: Hook checks should suppress output", test_name))
    }
}

// **Validates: Requirements 3.4.1, 3.4.2, 3.4.6**
@(test)
test_property_shell_code_syntax_validity :: proc(t: ^testing.T) {
    set_test_timeout(t)
    reset_test_state(t)
    // Property: Generated shell code must be syntactically valid ZSH
    // Property: All exported variables must follow ZSH_MODULE_* convention
    // Property: Generated code must include proper metadata comments
    
    test_cases := []struct{
        name: string,
        priority: int,
        has_hooks: bool,
        has_settings: bool,
        has_files: bool,
    }{
        {"simple-module", 10, false, false, false},
        {"module-with-hooks", 20, true, false, false},
        {"module-with-settings", 30, false, true, false},
        {"module-with-files", 40, false, false, true},
        {"complete-module", 50, true, true, true},
    }
    
    for test_case in test_cases {
        for iteration in 0..<3 { // 3 iterations per test case
            modules := make([dynamic]manifest.Module)
            defer {
                manifest.cleanup_modules(modules[:])
                delete(modules)
            }
            
            // Generate test module
            module := generate_shell_test_module(
                fmt.tprintf("%s-%d", test_case.name, iteration),
                test_case.priority,
                test_case.has_hooks,
                test_case.has_settings,
                test_case.has_files
            )
            append(&modules, module)
            
            // Capture emitted shell code by redirecting to a temporary file
            temp_file := fmt.tprintf("/tmp/zephyr_shell_test_%d.sh", generate_unique_id())
            defer os.remove(temp_file)
            
            // Since we can't easily capture stdout, we'll test the emit function indirectly
            // by calling it and checking that it doesn't crash
            loader.emit(modules)
            
            // Property: Emit function should complete without errors
            testing.expect(t, true, 
                fmt.tprintf("Emit function should complete successfully for %s (iter %d)", test_case.name, iteration))
            
            // Property: Module data should be properly structured for emission
            testing.expect_value(t, len(modules), 1)
            testing.expect(t, len(modules[0].name) > 0, "Module should have a valid name")
            
            if test_case.has_settings {
                testing.expect(t, len(modules[0].settings) > 0, "Module should have settings when expected")
            }
            
            if test_case.has_files {
                testing.expect(t, len(modules[0].files) > 0, "Module should have files when expected")
            }
            
            if test_case.has_hooks {
                testing.expect(t, len(modules[0].hooks.pre_load) > 0 || len(modules[0].hooks.post_load) > 0, 
                    "Module should have hooks when expected")
            }
        }
    }
}

// **Validates: Requirements 3.4.2, 3.4.4**
@(test)
test_property_shell_code_special_characters :: proc(t: ^testing.T) {
    set_test_timeout(t)
    reset_test_state(t)
    // Property: Shell code generation should handle special characters safely
    // Property: File paths should be properly quoted for shell safety
    // Property: Environment variable names should be sanitized
    
    special_cases := []struct{
        base_name: string,
        suffix: string,
    }{
        {"test", "-with-dashes"},
        {"test", "_with_underscores"},
        {"test", "123with456numbers"},
        {"module", "MixedCase"},
    }
    
    for special_case in special_cases {
        for iteration in 0..<2 { // 2 iterations per special case
            modules := make([dynamic]manifest.Module)
            defer {
                manifest.cleanup_modules(modules[:])
                delete(modules)
            }
            
            // Generate module with special characters
            module := generate_special_char_module(
                fmt.tprintf("%s-%d", special_case.base_name, iteration),
                special_case.suffix
            )
            append(&modules, module)
            
            // Test the emit function
            loader.emit(modules)
            
            // Property: Emit function should handle special characters without crashing
            testing.expect(t, true, 
                fmt.tprintf("Emit function should handle special characters for %s%s (iter %d)", 
                    special_case.base_name, special_case.suffix, iteration))
            
            // Property: Module should have expected structure
            testing.expect_value(t, len(modules), 1)
            testing.expect(t, len(modules[0].name) > 0, "Module should have a valid name")
            testing.expect(t, len(modules[0].files) > 0, "Module should have files with special characters")
            testing.expect(t, len(modules[0].settings) > 0, "Module should have settings with special characters")
        }
    }
}

// **Validates: Requirements 3.4.3, 3.4.5**
@(test)
test_property_shell_code_hook_safety :: proc(t: ^testing.T) {
    set_test_timeout(t)
    reset_test_state(t)
    // Property: Hook execution must include safety checks
    // Property: Hooks must be checked for existence before execution
    
    hook_test_cases := []struct{
        pre_hook: string,
        post_hook: string,
        should_be_safe: bool,
    }{
        {"valid_function_name", "another_valid_function", true},
        {"function_with_123", "function_with_underscores", true},
        {"ValidCamelCase", "valid_snake_case", true},
    }
    
    for hook_case in hook_test_cases {
        for iteration in 0..<2 { // 2 iterations per hook case
            modules := make([dynamic]manifest.Module)
            defer {
                manifest.cleanup_modules(modules[:])
                delete(modules)
            }
            
            // Generate module with specific hooks
            module := manifest.Module{
                name = strings.clone(fmt.tprintf("hook-test-%d", iteration)),
                version = strings.clone("1.0.0"),
                priority = 50,
                required = make([dynamic]string),
                optional = make([dynamic]string),
                files = make([dynamic]string),
                settings = make(map[string]string),
                platforms = manifest.Platform_Filter{
                    os = make([dynamic]string),
                    arch = make([dynamic]string),
                },
                hooks = manifest.Hooks{
                    pre_load = strings.clone(hook_case.pre_hook),
                    post_load = strings.clone(hook_case.post_hook),
                },
                path = strings.clone("/test/path"),
            }
            append(&modules, module)
            
            // Test the emit function
            loader.emit(modules)
            
            // Property: Emit function should handle hooks safely
            testing.expect(t, true, 
                fmt.tprintf("Emit function should handle hooks safely (iter %d)", iteration))
            
            // Property: Module should have expected hook structure
            testing.expect_value(t, len(modules), 1)
            testing.expect_value(t, modules[0].hooks.pre_load, hook_case.pre_hook)
            testing.expect_value(t, modules[0].hooks.post_load, hook_case.post_hook)
        }
    }
}

// **Validates: Requirements 3.4.1**
@(test)
test_property_shell_code_multiple_modules :: proc(t: ^testing.T) {
    set_test_timeout(t)
    reset_test_state(t)
    // Property: Multiple modules should be emitted in correct order
    // Property: Each module should be properly separated in output
    
    module_counts := []int{2, 3, 5, 8}
    
    for module_count in module_counts {
        for iteration in 0..<2 { // 2 iterations per count
            modules := make([dynamic]manifest.Module)
            defer {
                manifest.cleanup_modules(modules[:])
                delete(modules)
            }
            
            // Generate multiple modules with different priorities
            for i in 0..<module_count {
                module := manifest.Module{
                    name = strings.clone(fmt.tprintf("multi-module-%d-%d", iteration, i)),
                    version = strings.clone("1.0.0"),
                    priority = i * 10, // Different priorities
                    required = make([dynamic]string),
                    optional = make([dynamic]string),
                    files = make([dynamic]string),
                    settings = make(map[string]string),
                    platforms = manifest.Platform_Filter{
                        os = make([dynamic]string),
                        arch = make([dynamic]string),
                    },
                    path = strings.clone(fmt.tprintf("/test/path/module-%d", i)),
                }
                
                // Add some content to each module
                append(&module.files, strings.clone("init.zsh"))
                module_id := fmt.tprintf("%d", i)
                manifest.AddSetting(&module, "module_id", module_id)
                
                append(&modules, module)
            }
            
            // Test the emit function
            loader.emit(modules)
            
            // Property: Emit function should handle multiple modules
            testing.expect(t, true, 
                fmt.tprintf("Emit function should handle %d modules (iter %d)", module_count, iteration))
            
            // Property: All modules should be present
            testing.expect_value(t, len(modules), module_count)
            
            // Property: Each module should have expected structure
            for module, idx in modules {
                expected_name := fmt.tprintf("multi-module-%d-%d", iteration, idx)
                testing.expect_value(t, module.name, expected_name)
                testing.expect_value(t, len(module.files), 1)
                expected_id := fmt.tprintf("%d", idx)
                testing.expect_value(t, module.settings["module_id"], expected_id)
            }
        }
    }
}
