package test

import "core:testing"
import "core:fmt"
import "core:os"
import "core:strings"
import "core:path/filepath"
import "../src/loader"
import "../src/manifest"

// **Validates: Requirements 3.4.1, 3.4.2, 3.4.3, 3.4.4, 3.4.5, 3.4.6**
@(test)
test_shell_code_syntax_validity :: proc(t: ^testing.T) {
    // Property: Generated shell code must be syntactically valid ZSH
    // Property: All exported variables must follow ZSH_MODULE_* convention
    // Property: All file paths must be properly quoted and validated
    // Property: Hook execution must include safety checks
    
    // Create test modules with various configurations
    modules := make([dynamic]manifest.Module)
    defer {
        for module in modules {
            delete(module.required)
            delete(module.optional)
            delete(module.files)
            delete(module.platforms.os)
            delete(module.platforms.arch)
            delete(module.settings)
        }
        delete(modules)
    }
    
    // Module with settings, hooks, and files
    test_module := manifest.Module{
        name = strings.clone("test-module"),
        version = strings.clone("1.0.0"),
        description = strings.clone("Test module for shell code generation"),
        author = strings.clone("Test Author"),
        priority = 50,
        required = make([dynamic]string),
        optional = make([dynamic]string),
        files = make([dynamic]string),
        settings = make(map[string]string),
        platforms = manifest.Platform_Filter{
            os = make([dynamic]string),
            arch = make([dynamic]string),
        },
        hooks = manifest.Hooks{
            pre_load = strings.clone("test_pre_hook"),
            post_load = strings.clone("test_post_hook"),
        },
        path = strings.clone("/test/path/test-module"),
    }
    
    // Add some settings
    test_module.settings["debug"] = strings.clone("true")
    test_module.settings["timeout"] = strings.clone("30")
    
    // Add some files
    append(&test_module.files, strings.clone("init.zsh"))
    
    append(&modules, test_module)
    
    // Capture generated shell code
    temp_file := "/tmp/zephyr_test_output.sh"
    defer os.remove(temp_file)
    
    // Redirect stdout to capture the output
    old_stdout := os.stdout
    output_file, create_err := os.open(temp_file, os.O_CREATE | os.O_WRONLY | os.O_TRUNC, 0o644)
    testing.expect(t, create_err == os.ERROR_NONE, "Failed to create output file")
    
    if create_err == os.ERROR_NONE {
        os.stdout = output_file
        
        // Generate shell code
        loader.emit(modules)
        
        // Restore stdout
        os.close(output_file)
        os.stdout = old_stdout
        
        // Read generated content
        content, read_ok := os.read_entire_file(temp_file)
        testing.expect(t, read_ok, "Failed to read generated shell code")
        
        if read_ok {
            shell_code := string(content)
            defer delete(content)
            
            // Basic validation - just check that key components are present
            testing.expect(t, strings.contains(shell_code, "# Generated by Zephyr Shell Loader"), 
                          "Should contain header comment")
            testing.expect(t, strings.contains(shell_code, "export ZSH_MODULE_TEST_MODULE_DEBUG"), 
                          "Should contain environment variables")
            testing.expect(t, strings.contains(shell_code, "if typeset -f test_pre_hook"), 
                          "Should contain hook safety checks")
            testing.expect(t, strings.contains(shell_code, "# === Module: test-module v1.0.0 ==="), 
                          "Should contain module headers")
            
            // Property: Basic syntax validation
            validate_basic_shell_syntax(t, shell_code)
        }
    }
}

// Helper function to validate basic shell syntax rules
validate_basic_shell_syntax :: proc(t: ^testing.T, shell_code: string) {
    lines := strings.split_lines(shell_code)
    defer delete(lines)
    
    for line_num in 0..<len(lines) {
        line := lines[line_num]
        trimmed := strings.trim_space(line)
        
        // Skip empty lines and comments
        if len(trimmed) == 0 || strings.has_prefix(trimmed, "#") {
            continue
        }
        
        // Property: Export statements should have proper syntax
        if strings.has_prefix(trimmed, "export ") {
            testing.expect(t, strings.contains(trimmed, "="), 
                          fmt.tprintf("Export statement should contain '=' on line %d: %s", line_num + 1, line))
        }
        
        // Property: If statements should be properly closed
        if strings.has_prefix(trimmed, "if ") {
            testing.expect(t, strings.has_suffix(trimmed, "; then"), 
                          fmt.tprintf("If statement should end with '; then' on line %d: %s", line_num + 1, line))
        }
        
        // Property: Source statements should have quoted paths
        if strings.has_prefix(trimmed, "source ") {
            path_part := strings.trim_prefix(trimmed, "source ")
            testing.expect(t, strings.has_prefix(path_part, "\"") && strings.has_suffix(path_part, "\""), 
                          fmt.tprintf("Source path should be quoted on line %d: %s", line_num + 1, line))
        }
        
        // Property: No unmatched quotes (basic check)
        quote_count := strings.count(line, "\"")
        if quote_count > 0 {
            // Count escaped quotes
            escaped_quote_count := strings.count(line, "\\\"")
            actual_quote_count := quote_count - escaped_quote_count
            testing.expect(t, actual_quote_count % 2 == 0, 
                          fmt.tprintf("Unmatched quotes on line %d: %s", line_num + 1, line))
        }
    }
}

// **Validates: Requirements 3.4.3, 3.4.5**
@(test)
test_hook_name_validation :: proc(t: ^testing.T) {
    // Property: Unsafe hook names should be rejected
    
    // Test the is_safe_hook_name function directly
    testing.expect(t, !loader.is_safe_hook_name("rm -rf /"), "Should reject hook names with spaces")
    testing.expect(t, !loader.is_safe_hook_name("hook; rm file"), "Should reject hook names with semicolons")
    testing.expect(t, loader.is_safe_hook_name("valid_hook_name"), "Should accept valid hook names")
    testing.expect(t, loader.is_safe_hook_name("valid-hook-name"), "Should accept hook names with dashes")
}